\documentclass{article}

\usepackage[utf8]{inputenc}

\author{Youri Chancrin - Théo Descomps\\Samuel Khalifa - Jean-Baptiste Martinez}
\title{Rapport de projet Amazons}

\begin{document}
\maketitle

\section{Présentation du sujet}

L'objectif de ce projet est la création d'un serveur de jeu et de clients pouvant faire des parties 
du jeu des amazons.

Le jeu des amazons est un jeu de plateau où deux joueurs s'affrontent en jouant tour à tour.
Ils disposent chacun de reines, qui ont des mêmes déplacements que les reines des échecs.
Durant son tour, un joueur bouge une de ses reines, puis tire une flêche depuis la position atteinte par la reine.
La flêche est lancée sur l'une des 8 directions cardinales et ne peux traverser de reines ou d'autres flêches.

Le premier joueur qui ne peut pas jouer un coup valide perd.

Pour répondre à ce besoin, nous avons suivis les spécifications du sujet,
mis en place une infrastructure client-serveur, et réalisé plusieurs clients 
capable de jouer une partie, et souvent la gagner.

\subsection{Spécifications du sujet}
Le sujet dispose de deux grands types de spécifications.
Tout d'abord, une spécification structurelle, le client-serveur.
Secondement, des spécifications d'implémentations, avec l'Utilisation 
de GSL et de dlopen.

\subsubsection{Structure Client Serveur}

Le projet doit contenir un executable actant comme un serveur responsable d'une partie entre deux joueurs.
Le serveur doit s'assurer du lancement et du déroulement de la partie. Une fois celle-ci finie, 
il doit déclarer le vainqueur.

Le serveur est responsable de l'isolation des variables. 
C'est à lui de faire des copies du plateau du jeu au début de la partie et de les fournir aux clients 
pour qu'ils s'initialisent correctement.

Les clients doivent respecter une interface afin de garantir qu'ils puissent tous s'affronter,
quelque soit le serveur qui héberge la partie.

\subsubsection{Utilisation de GSL}

Pour représenter le plateau de jeu, la GNU Scientific Library (GSL) est utilisée.

Quatres plateaux de jeux doivent être implémentés, un carré, un donut, un huit et un trèfle.

\subsubsection{Utilisation de dllib}

Les clients sont des librairies dynamiques chargées avant le début de la partie par le serveur.
Le chargement doit être réalisé avec dllib.

\section{Modèle Client-Serveur}

Le modèle client serveur implique deux choses.
Premièrement, il est nécessaire d'isoler les responsabilités entre le module client et le module serveur.
Secondement, il est nécessaire d'avoir une interface pour que les modules puissent communiquer.
Cette dernière est imposée par le sujet.

\subsection{Isolation des responsabilités}

Le serveur est responsable du lancement, du déroulement, ainsi que la terminaison de la partie.
Le client est responsable des coups qu'il joue lorsque le serveur lui demande de jouer, 
en l'informant du coup de son adversaire au tour précédent.

On remarque que les deux modules ont besoin de pouvoir garder en mémoire l'évolution d'une partie.
Le serveur en a besoin pour savoir si un joueur fait un coup invalide.
Les clients en ont besoin pour suivre une stratégie cohérente.

On décide de faire un troisième module nommé Common qui implémentera toutes les fonctionnalités communes 
aux clients et au serveur.

\subsection{Interface entre client et serveur}

Les clients doivent disposer de quatres fonctions.
\begin{itemize}
    \item \textbf{get\_player\_name()} : Retourne le nom du joueur.
    \item \textbf{initialize()} : Permet au joueur de se prépaprer pour la partie à venir.
    \item \textbf{play(coup\_precedent)} : Demande au joueur un coup, en fonction 
    du coup fait par son adversaire au tour précédent.
    \item \textbf{finalize()} : Permet au joueur de libérer les ressources allouées.
\end{itemize}

Cette interface établie une généricité entre tous les clients et permet de les faire s'affronter.
Cela rend possible la création d'une compétition pour établir quelle est 
la meilleur stratégie.

\section{Module Serveur}

Le serveur s'occupe de gérer une partie jouée par deux clients. 

D'une part, il s'occupe de l'isolation de la mémoire lors de l'initialisation.
D'autre part, il doit être capable de déterminer le gagnant de la partie.


\subsection{Isolation de la mémoire}
Le serveur copie les données d'initialisation de la partie pour chaque client.
Cela empêcherait un potentiel client malicieux de modifier la mémoire du serveur ou 
de son adversaire.
Dans le cas où les clients et le serveur seraient sur des machines séparées, 
la question ne se poserait pas et les clients seraient contraints
d'allouer eux-mêmes la mémoire pour cette tâche.

\subsection{Détermination du vainqueur}
Au fur et à mesure de la partie, le serveur reçoit les coups des deux joueurs.
Il applique les modifications engendrées par ces coups sur un plateau dont seul lui a l'accès.
Ce plateau est fourni par le module Common. Lorsque que le serveur obtient le coup 
du joueur courrant, il effectue un test à l'aide la fonction \textbf{is\_move\_legal()} de l'interface board.h.
S'il reçoit la valeur false, le joueur courrant à perdu, l'autre joueur est donc le vainqueur.


\section{Module Common}
Le module Common contient un ensemble de fonctionnalités qui sont 
utilisées à la fois par le serveur et par les clients. 

\subsection{Structures de données}
Le module Common dispose de plusieurs structures de données et opérateurs utils :
\begin{itemize}
    \item \textbf{ArrayList} : Une liste d'objet quelconque.
    \item \textbf{PositionSet} : Un set de positions.
    \item \textbf{Arbre} : Un arbre d'objet quelconque. Utilise ArrayList.
    \item \textbf{Hash de Zobrist} : Permet de transformer un plateau de jeu en hash.
    \item \textbf{Board} : Une représentation du plateu de jeu.
\end{itemize}

Ces structures offrent une diversité de complexités dont les clients 
peuvent se servir pour minimiser leurs temps d'éxecutions.

Les avoir à disposition de tous les clients simplifie le prototypage de nouvelles stratégies.
Par exemple, la structure Arbre permet de modéliser un arbre des parties possibles pour les 
stratégies qui gardent en mémoire une prévision des prochains tours.

\subsection{Plateau de jeu}
Le plateau de jeu enveloppe le graphe fournit par GSL.
Ce-dernier étant dans un format optimisé, on choisit de ne jamais 
le modifier car c'est une opération couteuse et complexe. Pour 
enregistrer les évolutions de la partie, on utilise des 
tableaux représentant l'ensemble des cases du plateau.
Ces tableaux contiennent les flêches ainsi que les reines 
et permettent d'accéder au contenu d'une case en temps constant.


\section{Module Client}
Un client doit retourner un coup à jouer lorsque le serveur lui demande.
Ce coup doit être valide, si cela est possible.

Tous les clients disposent des fonctions de l'interface imposées.
La différence principale se situe au niveau de la fonction \textbf{play()}.

\section{Client Random}
\section{Client Alphabeta}
\section{Client MCTS}

\section{Optimisations}
Les clients les plus complexes nécessite une grande quantité de calculs.
Cependant, une contrainte du classement des clients est qu'ils puissent jouer en moins de deux secondes.
Après profilage du tour d'un client, certaines fonctions ont été améliorées.

Notamment \textbf{find\_nearest\_neighbor()} et \textbf{is\_cell\_empty()}, qui avaient des coûts faibles, 
mais qui étaient appelées très fréquement.

Cela pourrait être encore amélioré avec des 
optimisation de calculs des voisins sur les plateaus en grille, 
ce qui est le cas des plateaux du sujet.

\section{Conclusion}

\end{document}
