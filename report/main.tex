\documentclass{article}

\author{Youri Chancrin - Th\'eo Descomps\\Samuel Khalifa - Jean-Baptiste Martinez}
\title{Rapport de projet Amazons}

\begin{document}
\maketitle

\section{Pr\'esentation du sujet}

L'objectif de ce projet est la cr\'eation d'un serveur de jeu et de clients pouvant faire des parties 
du jeu des amazons.

Le jeu des amazons est un jeu de plateau o\`u deux joueurs s'affrontent en jouant tour \`a tour.
Ils disposent chacun de reines, qui ont des m\^emes d\'eplacements que les reines des \'echecs.
Durant son tour, un joueur bouge une de ses reines, puis tire une fl\^eche depuis la position atteinte par la reine.
La fl\^eche est lanc\'ee sur l'une des 8 directions cardinales et ne peux traverser de reines ou d'autres fl\^eches.

Le premier joueur qui ne peut pas jouer un coup valide perd.

\subsection{Contraintes}
Le sujet impose les contraintes suivantes :

\subsubsection{Structure Client Serveur}

Le projet doit contenir un executable actant comme un serveur responsable d'une partie entre deux joueurs.
Le serveur doit s'assurer du lancement et du d\'eroulement de la partie. Une fois celle-ci finie, 
il doit d\'eclarer le vainqueur.

Le serveur est responsable de l'isolation des variables. 
C'est \`a lui de faire des copies du plateau du jeu au d\'ebut de la partie et de les fournir aux clients 
pour qu'ils s'initialisent correctement.

Les clients doivent respecter une interface afin de garantir qu'ils puissent tous s'affronter,
quelque soit le serveur qui h\'eberge la partie.

\subsubsection{Utilisation de GSL}

Pour repr\'esenter le plateau de jeu, la GNU Scientific Library (GSL) est utilis\'ee.

Quatres plateaux de jeux doivent \^etre impl\'ement\'es, un carr\'e, un donut, un huit et un tr\`efle.

\subsubsection{Utilisation de dllib}

Les clients sont des librairies dynamiques charg\'ees avant le d\'ebut de la partie par le serveur.
Le chargement doit \^etre r\'ealis\'e avec dllib.

\section{Mod\`ele Client-Serveur}

Le mod\`ele client serveur implique deux choses.
Premi\`erement, il est n\'ecessaire d'isoler les responsabilit\'es entre le module client et le module serveur.
Secondement, il est n\'ecessaire d'avoir une interface pour que les modules puissent communiquer.
Cette derni\`ere est impos\'ee par le sujet.

\subsection{Isolation des responsabilit\'es}

Le serveur est responsable du lancement, du d\'eroulement, ainsi que la terminaison de la partie.
Le client est responsable des coups qu'il joue lorsque le serveur lui demande de jouer, 
en l'informant du coup de son adversaire au tour pr\'ec\'edent.

On remarque que les deux modules ont besoin de pouvoir garder en m\'emoire l'\'evolution d'une partie.
Le serveur en a besoin pour savoir si un joueur fait un coup invalide.
Les clients en ont besoin pour suivre une strat\'egie coh\'erente.

On d\'ecide de faire un troisi\`eme module nomm\'e Common qui impl\'ementera toutes les fonctionnalit\'es communes 
aux clients et au serveur.

\subsection{Interface entre client et serveur}

Les clients doivent disposer de quatres fonctions.
\begin{itemize}
    \item \textbf{get\_player\_name()} : Retourne le nom du joueur.
    \item \textbf{initialize()} : Permet au joueur de se pr\'epaprer pour la partie \`a venir.
    \item \textbf{play(coup\_precedent)} : Demande au joueur un coup, en fonction 
    du coup fait par son adversaire au tour pr\'ec\'edent.
    \item \textbf{finalize()} : Permet au joueur de lib\'erer les ressources allou\'ees.
\end{itemize}

Cette interface \'etablie une g\'en\'ericit\'e entre tous les clients et permet de les faire s'affronter.
Cela rend possible la cr\'eation d'une comp\'etition pour \'etablir quelle est 
la meilleur strat\'egie.

\section{Module Serveur}

Le serveur s'occupe de g\'erer une partie jou\'ee par deux clients. 

D'une part, il s'occupe de l'isolation de la m\'emoire lors de l'initialisation.
D'autre part, il doit \^etre capable de d\'eterminer le gagnant de la partie.


\subsection{Isolation de la m\'emoire}
Le serveur copie les donn\'ees d'initialisation de la partie pour chaque client.
Cela emp\^echerait un potentiel client malicieux de modifier la m\'emoire du serveur ou 
de son adversaire.
Dans le cas o\`u les clients et le serveur seraient sur des machines s\'epar\'ees, 
la question ne se poserait pas et les clients seraient contraints
d'allouer eux-m\^emes la m\'emoire pour cette t\^ache.

\subsection{D\'etermination du vainqueur}
Au fur et \`a mesure de la partie, le serveur re\c coit les coups des deux joueurs.
Il applique les modifications engendr\'ees par ces coups sur un plateau dont seul lui a l'acc\`es.
Ce plateau est fourni par le module Common. Lorsque que le serveur obtient le coup 
du joueur courrant, il effectue un test \`a l'aide la fonction \textbf{is\_move\_legal()} de l'interface board.h.
S'il re\c coit la valeur false, le joueur courrant \`a perdu, l'autre joueur est donc le vainqueur.


\section{Module Common}
Le module Common contient un ensemble de fonctionnalit\'es qui sont 
utilis\'ees \`a la fois par le serveur et par les clients. 

\subsection{Structures de donn\'ees}
Le module Common dispose de plusieurs structures de donn\'ees et op\'erateurs utils :
\begin{itemize}
    \item \textbf{ArrayList} : Une liste d'objet quelconque.
    \item \textbf{PositionSet} : Un set de positions.
    \item \textbf{Arbre} : Un arbre d'objet quelconque. Utilise ArrayList.
    \item \textbf{Hash} de Zobrist : Permet de transformer un plateau de jeu en hash.
    \item \textbf{Board} : Une repr\'esentation du plateu de jeu.
\end{itemize}

Ces structures offrent une diversit\'e de complexit\'es dont les clients 
peuvent se servir pour minimiser leurs temps d'\'executions.

Les avoir \`a disposition de tous les clients simplifie le prototypage de nouvelles strat\'egies.
Par exemple, la structure Arbre permet de mod\'eliser un arbre des parties possibles pour les 
strat\'egies qui gardent en m\'emoire une pr\'evision des prochains tours.

\subsection{Plateau de jeu}
Le plateau de jeu enveloppe le graphe fournit par GSL.
Ce-dernier \'etant dans un format optimis\'e, on choisit de ne jamais 
le modifier car c'est une op\'eration couteuse et complexe. Pour 
enregistrer les \'evolutions de la partie, on utilise des 
tableaux repr\'esentant l'ensemble des cases du plateau.
Ces tableaux contiennent les fl\^eches ainsi que les reines 
et permettent d'acc\'eder au contenu d'une case en temps constant.


\section{Module Client}
Un client doit retourner un coup \`a' jouer lorsque le serveur lui demande.
Ce coup doit \^etre valide, si cela est possible.

Tous les clients disposent des fonctions de l'interface impos\'ees.
La diff\'erence principale se situe au niveau de la fonction \textbf{play()}.

\section{Client Random}
\section{Client Alphabeta}
\section{Client MCTS}

\section{Optimisations}
Les clients les plus complexes n\'ecessite une grande quantit\'e de calculs.
Cependant, une contrainte du classement des clients est qu'ils puissent jouer en moins de deux secondes.
Apr\`es profilage du tour d'un client, certaines fonctions ont \'et\'e am\'elior\'ees.

Notamment \textbf{find\_nearest\_neighbor()} et \textbf{is\_cell\_empty()}, qui avaient des co\^uts faibles, 
mais qui \'etaient appel\'ees tr\`es fr\'equement.

Cela pourrait \^etre encore am\'elior\'e avec des 
optimisation de calculs des voisins sur les plateaus en grille, 
ce qui est le cas des plateaux du sujet.


\section{Conclusion}

\end{document}
