\documentclass{article}

\author{Youri Chancrin - Théo Descomps - Samuel Khalifa - Jean-Baptiste Martinez}
\title{Rapport de projet Amazons}

\begin{document}
\maketitle

\section{Présentation du sujet}

L'objectif de ce projet est la création d'un serveur de jeu et de clients pouvant faire des parties 
du jeu des amazons.

Le jeu des amazons est un jeu de plateau ou deux joueurs s'affrontent en jouant tour à tour.
Ils disposent chacun de reines, qui disposent des mêmes déplacements que les reines des échecs.
Durant son tour, un joueur bouge sa reine, puis tire une flêche depuis la position atteinte par la reine.
La flêche est lancée sur l'une des 8 directions cardinales et ne peux traverser de reines ou d'autres flêches.

Le premier joueur qui ne peut pas jouer perd.

\subsection{Contraintes}
Le sujet impose les contraintes suivantes :

\subsubsection{Structure Client Serveur}

Le projet doit contenir un executable actant comme un serveur responsable d'une partie entre deux joueurs.
Le serveur doit s'assurer du lancement et du déroulement de la partie. Une fois celle-ci finie, 
il doit déclarer le vainqueur.

Le serveur est responsable de l'isolation des variables. 
C'est à lui de faire des copies du plateau du jeu au début de la partie et de les fournir aux clients 
pour qu'ils s'initialisent correctement.

Les clients doivent respecter une interface afin de garantir qu'ils puissent tous s'affronter,
quelque soit le serveur qui héberge la partie.

\subsubsection{Utilisation de GSL}

Pour représenter le plateau de jeu, la GNU Scientific Library (GSL) est utilisée.

\subsubsection{Utilisation de dllib}

Les clients sont des librairies dynamiques chargées avant le début de la partie par le serveur.
Le chargement doit être réalisé avec dllib.

\section{Modèle Client-Serveur}

Le modèle client serveur implique deux choses.
Premièrement, il est nécessaire d'isoler les responsabilités entre le module client et le module serveur.
Secondement, il est nécessaire d'avoir une interface pour que les modules puissent communiquer.

\subsection{Isolation des responsabilités}

Le serveur est responsable du lancement, du déroulement, ainsi que la terminaison de la partie.
Le client est responsable des coups qu'il joue lorsque le serveur lui demande de jouer, 
en l'informant du coup de son adversaire au tour précédent.

On remarque que les deux modules ont besoin de pouvoir garder en mémoire l'évolution d'une partie.
Le serveur en a besoin pour savoir si un joueur fait un coup invalide.
Les clients en ont besoin pour suivre une stratégie cohérente.

On décide de faire un troisième module nommé Common qui implémentera toutes les fonctionnalités communes 
aux clients et au serveur.

\subsection{Interface entre client et serveur}


On découpe le projet en 3 parties
- Serveur
- Client
- Common


\section{Serveur}
Boucle de jeu : (à décrire)

Le serveur s'occupe de gérer une partie jouée par 2 clients. 
Le module Common contient un ensemble de fonctionnalités qui sont 
utilisées la fois par le serveur et par les clients. On y retrouve 
notamment diverses structures de données :
- arrayList
- Ensemble de positions
- Arbre

Ces structures offrent une diversité de complexité dont les clients 
peuvent se servir pour minimiser leurs temps d'éxecutions.

\section{Isolation de la mémoire}
=> Le serveur copie des données et les mets a disposition de chacun
des clients, dans le cas ou les clients et le serveur seraient sur 
des machines séparées, les clients devraient allouer leur mémoire.


\section{Client}

\section{Immutabilité du graphe}
=> Le graphe est sous un format optimisé, on choisit de ne jamais 
le modifier car c'est une opération couteuse et complexe. Pour 
enregistrer les évolutions de la partie, on utilise des 
tableaux représentant l'ensemble des cases du plateau.


\section{IA du client}
samuel la c'est pour toi

\section{Optimisations}
Modifications du code après profilage pour réduire le temps 
d'execution des clients.
- Optimisation des calculs sur plateau en grille.


\section{Conclusion}
On é trop fort
\end{document}
