\documentclass{article}

\author{Youri Chancrin - Théo Descomps - Samuel Khalifa - Jean-Baptiste Martinez}
\title{Rapport de projet Amazons}

\begin{document}
\maketitle

\section{Présentation du sujet}

L'objectif de ce projet est la création d'un serveur de jeu et de clients pouvant faire des parties 
du jeu des amazons.

Le jeu des amazons est un jeu de plateau où deux joueurs s'affrontent en jouant tour à tour.
Ils disposent chacun de reines, qui ont des mêmes déplacements que les reines des échecs.
Durant son tour, un joueur bouge une de ses reines, puis tire une flêche depuis la position atteinte par la reine.
La flêche est lancée sur l'une des 8 directions cardinales et ne peux traverser de reines ou d'autres flêches.

Le premier joueur qui ne peut pas jouer un coup valide perd.

\subsection{Contraintes}
Le sujet impose les contraintes suivantes :

\subsubsection{Structure Client Serveur}

Le projet doit contenir un executable actant comme un serveur responsable d'une partie entre deux joueurs.
Le serveur doit s'assurer du lancement et du déroulement de la partie. Une fois celle-ci finie, 
il doit déclarer le vainqueur.

Le serveur est responsable de l'isolation des variables. 
C'est à lui de faire des copies du plateau du jeu au début de la partie et de les fournir aux clients 
pour qu'ils s'initialisent correctement.

Les clients doivent respecter une interface afin de garantir qu'ils puissent tous s'affronter,
quelque soit le serveur qui héberge la partie.

\subsubsection{Utilisation de GSL}

Pour représenter le plateau de jeu, la GNU Scientific Library (GSL) est utilisée.

\subsubsection{Utilisation de dllib}

Les clients sont des librairies dynamiques chargées avant le début de la partie par le serveur.
Le chargement doit être réalisé avec dllib.

\section{Modèle Client-Serveur}

Le modèle client serveur implique deux choses.
Premièrement, il est nécessaire d'isoler les responsabilités entre le module client et le module serveur.
Secondement, il est nécessaire d'avoir une interface pour que les modules puissent communiquer.
Cette dernière est imposée par le sujet.

\subsection{Isolation des responsabilités}

Le serveur est responsable du lancement, du déroulement, ainsi que la terminaison de la partie.
Le client est responsable des coups qu'il joue lorsque le serveur lui demande de jouer, 
en l'informant du coup de son adversaire au tour précédent.

On remarque que les deux modules ont besoin de pouvoir garder en mémoire l'évolution d'une partie.
Le serveur en a besoin pour savoir si un joueur fait un coup invalide.
Les clients en ont besoin pour suivre une stratégie cohérente.

On décide de faire un troisième module nommé Common qui implémentera toutes les fonctionnalités communes 
aux clients et au serveur.

\subsection{Interface entre client et serveur}

Les clients doivent disposer de quatres fonctions.
\begin{itemize}
    \item get_player_name() : Retourne le nom du joueur.
    \item initialize() : Permet au joueur de se prépaprer pour la partie à venir.
    \item play(coup_precedent) : Demande au joueur un coup, en fonction 
    du coup fait par son adversaire au tour précédent.
    \item finalize() : Permet au joueur de libérer les ressources allouées.
\end{itemize}

Cette interface établie une généricité entre tous les clients et permet de les faire s'affronter.
Cela rend possible la création d'une compétition pour établir quelle est 
la meilleur stratégie.

\section{Module Serveur}

Le serveur s'occupe de gérer une partie jouée par deux clients. 

D'une part, il s'occupe de l'isolation de la mémoire lors de l'initialisation.
D'autre part, il doit être capable de déterminer le gagnant de la partie.


\subsection{Isolation de la mémoire}
Le serveur copie les données d'initialisation de la partie pour chaque client.
Dans le cas où les clients et le serveur seraient sur des machines séparées, 
la question ne se poserait pas et les clients seraient contraints
d'allouer eux-mêmes la mémoire pour cette tâche.

\subsection{Determination du vainqueur}
Au fur et à mesure de la partie, le serveur reçoit les coups des deux joueurs.
Il applique les modifications engendrées par ces coups sur un plateau dont seul lui a l'accès.
Ce plateau est fourni par le module Common. Lorsque que le serveur obtient le coup 
du joueur courrant, il effectue un test à l'aide la fonction is_move_legal() de l'interface board.h.
S'il reçoit la valeur false, le joueur courrant à perdu, l'autre joueur est donc le vainqueur.


\section{Module Common}
Le module Common contient un ensemble de fonctionnalités qui sont 
utilisées la fois par le serveur et par les clients. On y retrouve 
notamment diverses structures de données :
- arrayList
- Ensemble de positions
- Arbre

Ces structures offrent une diversité de complexité dont les clients 
peuvent se servir pour minimiser leurs temps d'éxecutions.

\subsection{Immutabilité du graphe}
=> Le graphe est sous un format optimisé, on choisit de ne jamais 
le modifier car c'est une opération couteuse et complexe. Pour 
enregistrer les évolutions de la partie, on utilise des 
tableaux représentant l'ensemble des cases du plateau.


\section{Module Client}
\section{IA du client}
samuel la c'est pour toi

\section{Optimisations}
Modifications du code après profilage pour réduire le temps 
d'execution des clients.
- Optimisation des calculs sur plateau en grille.


\section{Conclusion}
On é trop fort
\end{document}
